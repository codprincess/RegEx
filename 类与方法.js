//在正则表达式中具体特殊含义的字符：* + ? $ ^ . \ () {} []


//字符类
        // 1、元字符[]构建一个简单的类：'a1b1c1d1'.replace=('/[abc]/','0');

        // 字符类取反

        // 1、^不属于某个类的内容:'a1b1c1d1'.replace=('/[^abc]/','0');

//范围类

        // 1、[a-z]：a到z的任意字符，包含a和z本身

        // 2、[a-zA-Z]；大小写
        // 测试
        // 'a1b2c3d4xz9SDFFGHJ'.replace(/[a-zA-Z]/g,'Q')
        // "Q1Q2Q3Q4QQ9QQQQQQQ"
        // '2018-09-09'.replace(/[0-9-]/g,'A')
        // "AAAAAAAAAA"

//js预定义
        // '@123@abc@'.replace(/@./g,'Q')

        // "Q23Qbc@"

        // '@123@abc@'.replace(/^@./g,'Q')

        // "Q23@abc@"

        // '@123@abc@'.replace(/.@./g,'Q')

        // "@12Qbc@"

        // '@123@abc@'.replace(/.@/g,'Q')

        // "@12QabQ"

        // '@123@abc@'.replace(/.@$/g,'Q')

        // "@123@abQ"

//换行
        // mulSrt
        // "@123
        // @456
        // @789
        // "

        // mulSrt.replace(/^@\d/g,'X')
        // "X123
        // @456
        // @789
        // "

        // mulSrt.replace(/^@\d/gm,'X')
        // "X123
        // X456
        // X789
        // "

//量词
        // ？ 出现0或1次（最多1次）

        // +  出现1或多次（至少1次）

        // *  出现0或多次（任意次）

        // {n}  出现n次

        // {n，m}  出现n到m次

//js贪婪模式和非贪婪模式
        // '12345678'.replace(/\d{3,6}/g,'X')

        // "X78"贪婪模式：尽可能多的匹配

        // '12345678'.replace(/\d{3,6}?/g,'X')

        // "XX78"非贪婪模式：尽可能少的匹配
        //解释第一次贪婪模式，尽可能多的匹配，匹配了6个数字，所以只剩下78，第二次取消了贪婪模式，匹配了3个数字就停止了，但又是全文匹配，会接着继续匹配了3个数字，所以变成xx78


//分组
        // 'a1b2c3d4'.replace(/[a-z]\d{3}/g,'X') =>a1b2c3d4

        // 'a1b2c3d4'.replace(/([a-z]\d){3}/g,'X') =>Xd4

//分组反向引用
        // 匹配的可能是变量时的，用分组加反向引用 2015-12-25 == 12/25/2015

        // "2015-12-25".replace(/(\d{4})-(\d{2})-(\d{2})/g,"$2$3$1")

//前瞻(JavaScript不支持后顾)

        // 匹配到的字符是断言（(?=\d)）前面的，
        
        // 'a2*aa'.replace(/\w(?=\d)/,'H')    //"H2*aa"单词字符后面是数字的
        
        // 'dd4sfc'.replace(/\w(?!\d)/,'G');    //"Gd4sfc"单词字符后面不是数字的
        // 'a2*34v8vv'.replace(/\w(?=\d)/g,'X')

        // "X2*X4X8vv"

        // 匹配单词字符后面是数字的替换成X

        // 'a2*34v8vv'.replace(/\w(?!\d)/g,'X')

        // "aX*3XvXXX"

        // 匹配单词字符后面不是数字的替换成X

//test和exec方法
        // RegExp.prototype.test(str)：用于测试字符串参数中是否存在匹配正则表达式模式的字符串，存在返回true，否则返回false

        // var reg2=/\w/g;

        // 进行reg2.test('ab')时，第三次会变成false

        // 原因：while(reg2.test('ab')){

        //                 console.log(reg2.lastIndex);

        // }

        // 即进行test时，正则表达式的lastIndex会发生变化

        // 输出：1  2    表示第一个匹配上了、第二个匹配上了



        // RegExp.prototype.exec(str)：使用正则表达式模式对字符串执行搜索，并将更新全局RegExp对象的属性以反映匹配结果

        // 如果没有匹配则返回null，否则返回一个结果数组：index声明匹配文本的第一个字符的位置，input存放被检索的字符串string

        // 非全局调用：

        // 调用非全局的RegExp对象的exec（）时，返回数组

        // 第一个元素是与正则表达式相匹配的文本

        // 第二个元素是与RegExpObject的第一个子表达式（分组）相匹配的文本

        // 第三个元素是与RegExp对象的第二个子表达式（分组）相匹配的文本

        // 以此类推

//字符串对象方法
        // String.prototype.split(reg)
        // 1、经常使用split方法把字符串分割为字符数组；
        // "a,b,c,d".split(","); // ['a','b','c','d']
        // 2、在一些复杂的分割情况下：
        // "a1b2c3d".split(/\d/); //['a','b','c','d']

        // stringl.protatype.search(reg)

        // search()方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串

        // 方法返回第一个匹配结果index，查找不到返回-1

        // search（）方法不执行全局匹配，它将忽略标志g，并且总是从字符串开始进行检索



        // string.prototype.match(reg)

        // match（）方法将检索字符串，以找到一个或多个与regexp匹配的文本

        // regexp是否具有标志g对结果影响很大

        // 非全局调用：如果regexp没有标志g，那么match（）方法就只能在字符串中执行一次匹配，没找到任何匹配文本将返回null，否则将返回一个数组，其中存放了与它找到的匹配文本有关的信息：返回数组的第一个元素存放的是匹配文本，而其余元素存放的是与正则表达式的子表达式匹配的文本。

        // 除了常规数组元素之外，返回的数组还含有2个对象属性：index声明匹配文本的起始字符在字符串的位置；input声明对stringobject的引用



        // 全局调用：如果regexp具有标志g则match（）方法将执行全局检索，找到字符串中的所有匹配子字符串：没有找到任何匹配的子穿，则返回null，否则返回一个数组，数组元素中存放的是字符串中所有匹配子串，而且也没有index属性或input属性

